{
  "name": "tls-tunnel",
  "description": "A Server and client for proxying local ports through public interfaces",
  "version": "0.0.4",
  "homepage": "https://github.com/pghalliday/node-tls-tunnel",
  "author": {
    "name": "Peter Halliday",
    "email": "pghalliday@gmail.com",
    "url": "http://stuffpetedoes.blogspot.nl/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/pghalliday/node-tls-tunnel.git"
  },
  "bugs": {
    "url": "https://github.com/pghalliday/node-tls-tunnel/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/pghalliday/node-tls-tunnel/blob/master/LICENSE-MIT"
    }
  ],
  "main": "src/",
  "bin": {
    "tls-tunnel": "bin/cli.js"
  },
  "engines": {
    "node": ">= 0.8.12"
  },
  "scripts": {
    "test": "grunt"
  },
  "dependencies": {
    "node-uuid": "1.3.3"
  },
  "devDependencies": {
    "grunt": "0.3.17",
    "chai": "1.3.0",
    "grunt-mocha-test": "0.0.1",
    "checklist": "0.0.3"
  },
  "keywords": [
    "tls",
    "tunnel",
    "reverse proxy",
    "dynamic"
  ],
  "readme": "node-tls-tunnel\r\n===============\r\n\r\nA Node.js client/server implementation of a secure tunnel over TLS/SSL. Useful for exposing local servers on public hosts. Initially implemented to expose a local server to browsers provided by [BrowserStack](http://www.browserstack.com) to integrate their beta API with test scripts.\r\n\r\nThe idea is simple.\r\n\r\n- A server runs on a public host accepting connections on a public host name, let's say \"mytlstunnel.com\"\r\n- Initially only one port will be open and accepting connections, eg. 8080\r\n- On your local machine you start a client that connects to mytlstunnel.com:8080 using a TLS socket and let it know what local port it should expose, eg. 8000\r\n- The server assigns another port for use with that client and starts listening on it using an ordinary net socket, notifying the client on which port it will listen, eg 8081\r\n- When a third party tries to connect to mytlstunnel.com:8081 the server asks the client to make another connection using TLS to handle the traffic going through mytlstunnel.com:8081\r\n- The client does this and pipes all traffic to and from the third party on mytlstunnel.com:8081 and localhost:8000\r\n\r\n## Features\r\n\r\n- Can be used to tunnel HTTP or raw sockets\r\n- Can specify any host and port to forward to that is reachable by the client\r\n- Servers and clients can be instantiated within Node.js contexts\r\n- Servers can be configured to only accept connections from known clients (using SSL certificates), preventing strangers using your resources\r\n- Clients can be configured to validate against a known list of servers (using SSL certificates), preventing anyone from masquerading as your server\r\n- Servers can be configured to expose a predefined set of ports\r\n\r\n## Installation\r\n\r\n```\r\nnpm install tls-tunnel\r\n```\r\n\r\n## API\r\n\r\nTo instantiate and start a server \r\n\r\n```javascript\r\nvar fs = require('fs');\r\nvar Server = require('tls-tunnel').Server;\r\n\r\nvar server = new Server({\r\n  port: 8080,\t// port to listen for client connections\r\n  key: fs.readFileSync('./keys/server-key.pem'), \t// server's private key\r\n  cert: fs.readFileSync('./keys/server-cert.pem'),\t// server's SSL certificate\r\n  ca: [fs.readFileSync('./keys/client-cert.pem')],\t// list of authorized client SSL certificates\r\n  forwardedPorts: {\r\n    start: 8081,\t// Start of port range to assign to connecting clients\r\n    count: 10\t\t// maximum number of ports and hence clients that can be supported\r\n  },\r\n  timeout: 5000\t// Timeout in milliseconds to use when waiting for a client to provide a tunnel connection (default is 2000)\r\n});\r\n\r\nserver.start(function() {\r\n  // server should be listening on port 8080 now\r\n  server.stop(function() {\r\n    // server should have ended all connections and stopped\r\n  });\r\n});\r\n```\r\n\r\nTo instantiate and connect a client\r\n\r\n```javascript\r\nvar fs = require('fs');\r\nvar http = require('http');\r\nvar Client = require('tls-tunnel').Client;\r\n\r\nvar client = new Client({\r\n  tunnel: {\r\n    host: 'mytlstunnel.com',  // the host where the server is running\r\n    port: 8080,               // the port on which the server is running\r\n    key: fs.readFileSync('./keys/client-key.pem'),    // client's private key\r\n    cert: fs.readFileSync('./keys/client-cert.pem'),  // client's SSL certificate\r\n    ca: [fs.readFileSync('./keys/server-cert.pem')]   // list of authorized server SSL certificates\r\n  },\r\n  target: {\r\n    host: 'localhost',  // the target host to expose through the tunnel\r\n    port: 8000,         // the target port to expose through the tunnel\r\n  },\r\n  timeout: 5000\t// Timeout in milliseconds to use when waiting for a server to assign a public port (default is 2000)\r\n});\r\n\r\nclient.connect(function(error, port) {\r\n  if (error) {\r\n    // errors could include not having enough ports available on\r\n    // the server to support another\r\n  } else {\r\n    // only if no errors were encountered will the <port> parameter\r\n    // contain the public port that was assigned for the tunnel\r\n    http.get('http://mytlstunnel.com:' + port, function(res) {\r\n      res.on('data', function() {\r\n        // should receive the response from localhost:8000 here \r\n        // (if it's listening of course)\r\n      });\r\n      res.on('end', function() {\r\n        client.disconnect(function() {\r\n          // client should have ended all connections\r\n        });\r\n      });\r\n    });\r\n  }\r\n});\r\n```\r\n\r\n## Hints on generating certs for testing\r\n\r\nSee the ``test/keys`` folder for certificates used by the tests. These can be regenerated at anytime using either ``keys.sh`` (OSX, Linux) or ``keys.bat`` (Windows). These scripts use [OpenSSL](http://www.openssl.org). OSX and Linux most likely already ship with OpenSSL. If using Windows you will need to install [OpenSSL](http://slproweb.com/products/Win32OpenSSL.html) first.\r\n\r\nIt should be noted that for the client to authorize server certificates they need to have the correct hosts listed as altnames in the v3 extensions (although this doesn't seem to be required on Windows).\r\n\r\n## Roadmap\r\n\r\n- Server should support other kinds of switchboard so that it no longer requires more than one port\r\n- Test keys and certs need to be generated when running tests as they will eventually expire\r\n- Tunnel should support TLS and HTTPS traffic\r\n- Client should be configurable to only accept a limited number of connections\r\n- Server or client should be runnable from the shell\r\n\r\n## Contributing\r\nIn lieu of a formal styleguide, take care to maintain the existing coding style. Add unit tests for any new or changed functionality. Lint and test your code using ``./grunt.sh`` or ``.\\grunt.bat``.\r\n\r\n## Release History\r\n_(Nothing yet)_\r\n\r\n## License\r\nCopyright (c) 2012 Peter Halliday  \r\nLicensed under the MIT license.",
  "_id": "tls-tunnel@0.0.4",
  "dist": {
    "shasum": "d52f467da7d801cd5f89801a20d3b9f1a064d6fe"
  },
  "_from": "tls-tunnel@0.0.4"
}
