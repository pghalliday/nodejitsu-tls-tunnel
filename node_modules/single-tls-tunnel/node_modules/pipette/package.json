{
  "name": "pipette",
  "version": "0.9.1",
  "keywords": [
    "stream",
    "pipe",
    "buffer",
    "valve",
    "data",
    "event",
    "blip",
    "cat",
    "sink",
    "slicer",
    "reader",
    "read",
    "dropper"
  ],
  "description": "Stream and pipe utilities for Node",
  "homepage": "https://github.com/Obvious/pipette",
  "repository": {
    "type": "git",
    "url": "https://github.com/Obvious/pipette.git"
  },
  "licenses": [
    {
      "type": "Apache 2.0",
      "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
    }
  ],
  "author": {
    "name": "Dan Bornstein",
    "email": "danfuzz@milk.com",
    "url": "http://www.milk.com/"
  },
  "maintainers": [
    {
      "name": "Dan Bornstein",
      "email": "danfuzz@obvious.com",
      "url": "http://www.milk.com/"
    }
  ],
  "dependencies": {
    "typ": "~0.6.1"
  },
  "main": "lib/pipette.js",
  "engine": {
    "node": ">=0.6.0"
  },
  "scripts": {
    "test": "node test/test.js"
  },
  "readme": "pipette: Stream and pipe utilities for Node\n===========================================\n\nThis Node module provides several utility classes that offer\npipe and stream-related functionality. It particularly emphasizes\nproviding a consistent event packaging and ordering for streams.\n\n\nBuilding and Installing\n-----------------------\n\n```shell\nnpm install pipette\n```\n\nOr grab the source and\n\n```shell\nnpm install\n```\n\n\nTesting\n-------\n\n```shell\nnpm test\n```\n\nOr\n\n```shell\nnode ./test/test.js\n```\n\n\nEvent Sequence Philosophy\n-------------------------\n\nAll of the classes in this module provide a consistently ordered\nsequence of events, which is meant to be a sensible synthesis of the\n(somewhat inconsistent) Node specification for the various core\nstream classes.\n\nIn particular, a stream will emit some number of `data` events\n(possibly zero), each with a single payload argument. This will be\nfollowed by *either* an `end` event with no payload or an `error`\nevent with an arbitrary payload. This is followed by a `close` event\nwith no payload. After that, a stream will not emit any further\nevents, and it is furthermore guaranteed to be detached from its\nupstream source(s), if any.\n\nMore schematically, as a \"railroad\" diagram:\n\n```\n        +--------------------+      +-------+\n        |                    |   +->| end() |----------+\n        v  +---------------+ |   |  +-------+          |  +---------+\n(start)-+->| data(payload) |-+-+-+                     +->| close() |->(finish)\n        |  +---------------+   ^ |  +----------------+ |  +---------+\n        |                      | +->| error(payload) |-+\n        +----------------------+    +----------------+\n```\n\nOf particular note are the cases of inconsistently-defined `close`\nevents. Some streams (core Node stream classes, for example) will emit\na `close` event with a non-empty payload value to indicate an\nunexpected termination. The classes in this module consistently\ntranslate such cases to an `error` event with the error payload\nfollowed by a no-payload `close` event. For the purposes of this\nmodule, a \"non-empty payload\" is one that is neither `undefined` nor\n`false`. This takes care of the quirky definitions of `net.Socket`\n(which includes a boolean error indicator in its `close` event) and\n`http.ClientResponse` (which may include an arbitrary error object in\nits `close` event).\n\nThe particularly nice thing about this arrangement is that if one\nwants to consistently do something after a stream has finished, one\ncan write the something in question as a `close` event handler, rather\nthan splaying the logic between both an `end` and an `error` handler.\n\nIn the rest of the documentation, it should be taken as implicit that\nall the classes' event sequences follow this order.\n\n\nLayering Philosophy\n-------------------\n\nFour of these classes (`Cat`, `Sink`, `Slicer`, and `Valve`) provide a\nlayer on top of other streams. The implementation philosophy is that\nthese listen for events from their \"upstream\" sources, but they do not\notherwise attempt to interact with those streams. In particular:\n\n* They do not make upstream calls to the flow-control methods\n  `pause()` and `resume()`.\n\n* They do not attempt to make upstream `setEncoding()` calls.\n\n* They do not call upstream `destroy()` even when they themselves are\n  being `destroy()`ed.\n\nIn addition, these layering classes check upon construction that their\nupstream sources are in fact streams that have not yet been ended\n(that is, that they are still capable of emitting events). If a stream\nsource argument fails this check, then the constructor call will throw\nan exception indicating that fact. The check is somewhat conservative\n(on the side of accepting) and meant to accept stream-like event\nemitters in addition to checking bona fide `Stream` instances.\nDetails: If a given source is a `Stream` per se, then the value of\n`source.readable` is taken at face value. Otherwise, a source is\nconsidered to be ended if and only if it (or a prototype in its chain)\ndefines a `readable` property and that property's value is falsey.\n\n### Constructing stacked readers\n\nMany Node stream classes are designed as an atomic unit that includes\nboth reader and writer methods intermingled in a single object. This\nmodule takes a different tack:\n\n* Any given object is either a reader or a writer, never both.\n\n* To pass one reader's event output to another, construct the destination\n  object passing it the source, e.g. `new Valve(new OtherStream(...))`.\n\n### Getting a writer\n\nIf you need to get a writer to write into one of the reader classes\n(or a stack of same), you can use a `Pipe`:\n\n```javascript\nvar pipe = new Pipe();\nvar readerStack = new OtherStream(pipe.reader);\nvar writer = pipe.writer;\n\nwriter.write(...); // What's written here will get read by the OtherStream.\n```\n\n\nA Note About Encodings\n----------------------\n\nNode 0.6.* and 0.8.* differ in their documentation about which encodings\nare allowed by `setEncoding()`. This module accepts the union of the\nencodings specified by those. This includes:\n\n* `ascii` &mdash; 7-bit ASCII\n* `base64` &mdash; standard Base-64 encoding for binary data\n* `hex` &mdash; hex encoding for binary data (two hexadecimal ASCII\n  characters per byte)\n* `ucs2` &mdash; alias for `utf16le` (below). This is not technically correct\n  (per Unicode spec), but it is how Node is defined.\n* `utf16le` &mdash; standard little-endian UTF-16 encoding for Unicode data\n* `utf8` &mdash; standard UTF-8 encoding for Unicode data\n\n\nCommon Options\n--------------\n\nAll of the classes in this module take an optional `options`\nconstructor parameter. If not `undefined`, this must be a map from\noption names to values as specified by the class.\n\nThe following are three commonly-accepted options. Classes all accept\nwhichever of these make sense.\n\n* `encoding` &mdash; A string representing the encoding to use when\n  emitting events. Passing this option is exactly like calling\n  `setEncoding()` on the constructed instance.\n\n* `incomingEncoding` &mdash; A string representing the incoming\n  encoding to use when interpreting incoming `data` events that arrive\n  as strings (as opposed to buffers). Passing this option is exactly\n  like calling `setIncomingEncoding()` on the constructed instance.\n\n* `paused` &mdash; A boolean value indicating whether the instance\n  should be immediately paused. For most classes, this is exactly like\n  calling `pause()` on the constructed instance.\n\n\n* * * * * * * * * *\n\nAPI Details\n===========\n\nBlip\n----\n\nThe `Blip` class exists to emit a single `data` event.\n\nThis class is useful if you have data that you need to re-emit.\n\n### var blip = new Blip([data], [options])\n\nConstructs and returns a new blip which is to emit the given `data`\n(a string or buffer) once unpaused. After emitting the `data` event,\nblips always also emit an `end` and a `close` event (in that order).\n\nOf the common options, Blip recognizes `encoding` and\n`incomingEncoding`, though the latter is with a twist: The\n`incomingEncoding` (either as specified or with the default behavior)\napplies immediately to the given `data`, in order to transform it into\na buffer. That is, if `data` is passed as a string, it will always get\nimmediately transformed into a buffer, when an instance is\nconstructed.\n\nIf `data` is omitted, then the resulting blip will *just* emit the\nending events, without a `data` event first.\n\nBlips start out paused, since there is not much point in them\nimmediately emitting their contents upon construction (as there\nwill necessarily be no listeners at that moment).\n\nThe constructed instance obeys the full standard Node stream protocol\nfor readers.\n\n\nCat\n---\n\nThe `Cat` class (short for \"concatenate\" and by analogy with the\ntraditional Unix command with the same name) emits the events from\na sequence of streams, in the order of the given sequence (i.e.\nnot interspersed).\n\nThis can be used, for example, to produce a stream that is prefixed\nor suffixed with a given bit of data (when used in combination with\n`Blip`, above).\n\n### var cat = new Cat(streams, [options])\n\nConstructs and returns a new cat which is to emit the events from\nthe given streams (each of which must be an `EventEmitter` and is\nassumed to emit the standard Node readable stream events).\n\nThe data events from each stream (in order) are in turn emitted by\nthis instance, switching to the next stream when the current stream\nemits either an `end` or `close` event. After all the streams have\nbeen \"consumed\" in this fashion, this instance emits an `end` and then\na `close` event.\n\nIf a stream should emit an `error` event, then that event is in turn\nemitted by this instance, after which this instance emits a `close`\nevent. It will then become closed (emitting no further events, and\nproducing `false` for `cat.readable`).\n\nThis class recognizes all three of the common options (see above), and\nno others.\n\nThe constructed instance obeys the full standard Node stream protocol\nfor readers.\n\n### cat.setIncomingEncoding(name)\n\nSets the incoming encoding of the stream. This is the encoding to use\nwhen interpreting strings that arrive in `data` events. (This is as\nopposed to the encoding set by `setEncoding()` which determines how\nthe collected data is transformed as it gets emitted from an\ninstance.)\n\nThe `name` must be one of the unified allowed encoding names for\n`Stream.setEncoding()`.\n\nThe incoming encoding starts out as `undefined`, which is taken to\nbe synonymous with `\"utf8\"` should a `data` event be received\ncontaining a string payload.\n\n\nDropper\n-------\n\nThe `Dropper` class is a bufferer of readable stream events, which\nrelays those events in fixed size blocks (or multiples thereof),\na.k.a. \"drops\" (hence the name). It handles pause/resume semantics,\nand it will always translate incoming values that aren't buffers into\nbuffers, using a specified and settable incoming encoding.\n\nThe only exception to the block size is that the last `data` event\nfrom a Dropper may have a smaller size, if the last data it received\n(before an `end` or `error`) would not end up filling up a block of\nthe specified size. In this case, the behavior is specified by\nthe `ifPartial` option (see below).\n\nOther than the fixed-size block part, the semantics of this class are\nbasically the same as the simpler `Valve` class (see below).\n\n### var dropper = new Dropper(source, [options])\n\nConstructs and returns a new dropper, which listens to the given source.\nThis takes an optional `options` argument, which if present must be\na map of options, including any of the common options (see above)\nas well as any of the following:\n\n* `size` &mdash; block (aka drop) size in bytes. Must be a positive\n  integer. Defaults to `1`.\n\n* `allowMultiple` &mdash; whether emitted data events are to be the\n   exact block size (`false`) or may be an even multiple of the block\n   size (`true`). Must be a boolean. Defaults to `false`.\n\n* `ifPartial` &mdash; what to do with a partial block at the\n   end of the stream; one of `emit` (emit it as-is),\n   `ignore` (drop it entirely), `pad` (zero-pad), `error` (emit\n   an error). Defaults to `emit`.\n\nThe constructed instance obeys the full standard Node stream protocol\nfor readers.\n\n(Note: As of this writing, this is the only one of the classes in this\nmodule that takes an options object on construction. It is likely that\nthe rest of the classes will migrate to this form.)\n\n### dropper.setIncomingEncoding(name)\n\nSets the incoming encoding of the stream. This is the encoding to use\nwhen interpreting strings that arrive in `data` events. (This is as\nopposed to the encoding set by `setEncoding()` which determines how\nthe collected data is transformed as it gets emitted from an\ninstance.)\n\nThe `name` must be one of the unified allowed encoding names for\n`Stream.setEncoding()`.\n\nThe incoming encoding starts out as `undefined`, which is taken to\nbe synonymous with `\"utf8\"` should a `data` event be received\ncontaining a string payload.\n\n\nPipe\n----\n\nThe `Pipe` class is a simple in-memory pipe, which provides writer and\nreader ends. Pipes handle data encoding and obey pause/resume semantics.\n\nThis class is useful if you have code that wants to call writable stream\nstyle methods, and you want it to be directly attached to some other code\nthat expects to be listening for events. For example:\n\n```javascript\nvar listeningThingy = ...;\nvar writingThingy = ...;\n\nvar pipe = new Pipe();\nlisteningThingy.listenTo(pipe.reader);\nwritingThingy.writeTo(pipe.writer);\n```\n\n### var pipe = new Pipe([options])\n\nConstructs and returns a new pipe pair. The result is an object with\nmappings for `{ reader, writer }` for the two ends of the pipe.\n\nThe reader and writer side each implement the standard Node stream\nprotocol for readable and writable streams (respectively).\n\nThe specified protocol allows writers to ignore the `fd` argument\nto `stream.write()`, and this implementation in fact ignores it.\n\nOf the common options, the constructor accepts `encoding` and `paused`,\nwhich both apply to the reader end of the pipe.\n\n\nSink\n----\n\nThe `Sink` class is an in-memory collector of all the data read from a\ngiven stream. It is in turn itself a stream that emits no more than a\nsingle `data` event consisting of all of the data it received, once\nits upstream source has ended. It also has direct accessors method to\nget at the data or a stream-ending error, to provide a bit of\nflexibility in how the class is used.\n\nThis class is useful for cases where you don't care about incremental\nprocessing and just want to deal with the whole enchilada (as it\nwere). This can be used to collect an entire post body from an HTTP\nrequest, for example:\n\n```javascript\nvar httpServer = http.createServer(onRequest);\n\nfunction onRequest(request, response) {\n  var postData = new Sink(request);\n  postData.on(\"data\", onPostData);\n\n  function onPostData(data) {\n    console.log(\"Got post:\", data.toString());\n  }\n}\n```\n\n### var sink = new Sink(source, [options])\n\nConstructs and returns a new sink, which listens to the given source\nstream. Once the stream has ended (via either an `end` or `close`\nevent), this instance emits a single `data` event containing all\nof the data received from the source (if there was any data at all),\nfollowed by an `end` and then a `close` event.\n\nIf the source should ever emit an `error` event, then this will cause\nthe sink instance to first emit any data it received (as a single\n`data` event), followed by an `error` event that corresponds to the\none it received, and finally followed by a `close` event. After that,\nit will emit no further events.\n\nThis class recognizes all three of the common options (see above), and\nno others.\n\nThe constructed instance obeys the full standard Node stream protocol\nfor readers.\n\nIn addition to being readable streams, sinks have a few more methods.\n\n### sink.getData() => buffer || string || undefined\n\nGets the final complete data for the sink, if available.\n\nIf the sink's source has not yet ended, or if it ended without\never emitting any data, this returns `undefined`.\n\nIf the sink received any data and has a specified encoding (via\n`setEncoding()`), this returns the string form of the data, as decoded\nusing the named encoding.\n\nIf the sink received any data but has no specified encoding, this\nreturns the straight buffer of data.\n\nNote that this method can return a defined (that is, not `undefined`)\nvalue before the corresponding `data` event is emitted, particularly\nif the sink happens to be paused at the time the upstream stream is\nended.\n\nAlso note that there is a bit of ambiguity with this method, in terms of\ndifferentiating a stream that got ended with no data ever received\nwith one that simply hasn't yet ended. Instead of using this method\nfor that purpose, use `sink.readable` (part of the standard readable\nstream protocol).\n\n### sink.getError() => any\n\nGets the error that terminated the upstream source, if available.\n\nIf the sink's source has not yet ended, or if it ended normally, this\nreturns `undefined`.\n\nIf the sink's source ended with an `error` event, then this returns the\nsame value that was received in that error event.\n\nNote that this method can return a defined (not `undefined`) value\nbefore the corresponding `error` event is emitted, particularly if the\nsink happens to be paused at the time the upstream stream reports its\nerror.\n\nAlso note that there is a bit of ambiguity in terms of interpreting a\nstream that got ended with an `error` event whose payload is\n`undefined`. If you need to account for this possibility, use\n`sink.gotError()`.\n\n### sink.gotError() => boolean\n\nGets whether or not the upstream source was ended with an error.\n\nThis returns `false` if the source has not yet ended, or if it ended\nnormally.\n\nThis returns `true` if and only if the upstream source emitted an\n`error` event that this sink instance received.\n\nNote that this method can return `true` before the corresponding\n`error` event is emitted, particularly if the sink happens to be\npaused at the time the upstream stream reports its error.\n\n### sink.setIncomingEncoding(name)\n\nSets the incoming encoding of the stream. This is the encoding to use\nwhen interpreting strings that arrive in `data` events. (This is as\nopposed to the encoding set by `setEncoding()` which determines how\nthe collected data is transformed as it gets emitted from an\ninstance.)\n\nThe `name` must be one of the unified allowed encoding names for\n`Stream.setEncoding()`.\n\nThe incoming encoding starts out as `undefined`, which is taken to\nbe synonymous with `\"utf8\"` should a `data` event be received\ncontaining a string payload.\n\n\nSlicer\n------\n\nThe `Slicer` class (like `Sink`) is an in-memory bufferer of data\nread from a given stream. In turn, it provides a `fs.read()` style\ninterface to get at the data so-read.\n\nAs the name implies, this class is useful for slicing up a stream\ninto chunks that aren't (necessarily) the same shape as the ones\nthat came in as `data` events.\n\nMost of the \"interesting\" methods on the class take a callback\nargument to receive data back from the instance. These are all\nconsistently called as `callback(error, length, buffer, offset)` with\nno `this` and with arguments defined as follows:\n\n* `error` &mdash; a boolean flag indicating whether the read was cut short\n  due to an error *or* because there was insufficient data to fully\n  comply with the request. (Note: This is different than `fs.read()`\n  which passes an error object here. See `slicer.gotError()` below for\n  an explanation of why.)\n\n* `length` &mdash; the number of bytes read.\n\n* `buffer` &mdash; the buffer that was read into.\n\n* `offset` &mdash; the offset into `buffer` where the reading was done.\n\nThe ordering and meaning of the callback arguments are meant to be (a)\ncompatible with callbacks used with `fs.read()` and (b) somewhat more\ninformative and unambiguous.\n\n### var slicer = new Slicer(source, [options])\n\nConstructs a new slicer, which listens to the given source.\n\nOf the common options, the only one recognized by this class is\n`incomingEncoding`. The class accepts no other options.\n\nThis class recognizes all three of the common options (see above), and\nno others.\n\n\n### slicer.readable => boolean\n\nThis indicates whether there is any data left to be read in the stream\nor whether there *could* be any day left to be read.\n\nIn particular, this only becomes `false` when it is both the case that\nthe buffer of pending data is empty *and* the upstream source has ended.\n\nThis field is meant to be reasonably analogous to the readable stream\nfield of the same name.\n\n### slicer.destroy()\n\nCauses the instance to be cleaned up and become closed. In particular,\nit includes detaching from the upstream source. After this method is\ncalled, other methods on this class will behave as if the upstream\nsource ended with no error.\n\nThis method is meant to be reasonably analogous to the readable stream\nfield of the same name.\n\n### slicer.setIncomingEncoding(name)\n\nSets the incoming encoding of the source stream. This is the encoding\nto use when interpreting strings that arrive in `data` events.\n\nThe `name` must be one of the unified allowed encoding names for\n`Stream.setEncoding()`.\n\nThe incoming encoding starts out as `undefined`, which is taken to\nbe synonymous with `\"utf8\"` should a `data` event be received\ncontaining a string payload.\n\n### slicer.gotError() => boolean\n\nIndicates whether the upstream source has indicated an error condition.\nThis is out-of-band with respect to the data, in that there may still\nbe data that can be successfully read even if this method returns `true`.\n\nThis method exists to help disambiguate the case of not\nhaving gotten an error indicator from the case of having gotten an\nerror indicator but without any error instance payload.\n\n### slicer.getError() => any\n\nGets the error payload that was reported from upstream, if any.\nThis is out-of-band with respect to the data, in that there may still\nbe data that can be successfully read even if this method returns a\ndefined value.\n\nThis will always return `undefined`, unless the upstream source\nreported an error with a defined payload.\n\n### slicer.readAll(callback)\n\nReads as much data as possible from the stream, blocking the callback\n*only* in order to make it to the head of the read queue.\n\nTo be clear, if there is no data available in the slicer at the time\nthis read becomes potentially-serviced, then it will in fact get\nserviced, with the callback indicating that zero bytes were read\nwithout error.\n\nThe `buffer` in the callback will always be a freshly-allocated buffer\nthat does not share its data with any other instance.\n\n### slicer.read(length, callback)\n\nReads exactly `length` bytes of data from the stream if at all\npossible, blocking the callback until either `length` bytes are\navailable or the stream has ended (either normally or with an error).\n\nIf `length` is passed as `0` it means \"read zero bytes\". This can be\nuseful as a way to insert a no-data \"sentinal\" callback into the\nsequence of callbacks coming from this instance.\n\nTo be clear, the callback will only ever indicate a shorter `length`\nthan requested if the upstream source ends without at least `length`\nbytes being available. If a short read ends up happening, then the\ncallback will get passed `true` for the error flag.\n\nThe `buffer` in the callback will always be a freshly-allocated buffer\nthat does not share its data with any other instance.\n\n### slicer.readInto(buffer, offset, length, callback)\n\nReads some amount of data from the stream into the indicated `buffer`\n(which must be a `Buffer` instance), starting at the indicated\n`offset` and reading exactly `length` bytes if at all possible.\n\nIf `offset` is passed as `undefined` it defaults to `0`.\n\nIf `length` is passed as `undefined` it means \"read as much as\npossible without blocking\". This is different than passing `0` which\nmeans simply \"read zero bytes\". (This latter case can actually be\nuseful. See `slicer.read(length, callback)` above.)\n\nAs with `read()`, the only time the length will be shorter than what\nwas requested will be if the stream ends without there being at least\n`length` bytes to read. If a short read ends up happening, then the\ncallback will get passed `true` for the error flag.\n\n\nValve\n-----\n\nThe `Valve` class is a bufferer of readable stream events, which\nrelays those events consistently. It handles pause/resume semantics,\nand it will always translate incoming values that aren't buffers into\nbuffers, using a specified and settable incoming encoding.\n\nOne of the major use cases of this class is to use it to capture the\ndata coming from a network stream that's already in the middle of\nproducing data, particularly when you don't immediately know where\nthat data needs to go to. The author has run into this on multiple\noccasions when trying hand off reading from an HTTP connection\nacross a tick boundary, along these lines for example (obviously\nsimplified here):\n\n```javascript\nvar thingThatWantsToRead = {\n  startReading: function (stream) {\n    stream.on(\"data\", ...);\n    stream.resume();\n    ...\n  },\n  ...\n}\n\nfunction httpRequestCallback(request, response) {\n  var valve = new Valve(request, true);\n\n  process.nextTick(function () {\n    thingThatWantsToRead.startReading(valve);\n  });\n}\n```\n\nAnother handy use for Valve is *just* to provide consistent data\npayloads (always buffers, or always properly encoded strings) and the\nconsistent event ordering generally guaranteed by this module. In\nparticular on the event type front, the standard Node HTTP and HTTPS\nstreams are inconsistent with the core `Stream` in that they can emit\n`close` events that contain either a boolean error flag or a full-on\n`Error` instance. By layering a `Valve` on top of them, these get\ntranslated into a consistent `error`-then-`close` sequence.\n\nSimilarly, if you want to implement a `Stream` as part of your own API\nbut don't want to deal with all the fiddly bits, you can write a\nstraightforward `EventEmitter`, and then expose it via a Valve, as in:\n\n```javascript\nfunction MyEventEmitter() {\n  events.EventEmitter.call(this);\n  ...\n}\n\nutil.inherits(this, events.EventEmitter);\n\nfunction createMyStream() {\n  var coreEmitter = new MyEventEmitter();\n  return new pipette.Valve(coreEmitter);\n}\n```\n\nThe Valve will \"sanitize\" the events coming from your class, while\nalso providing the rest of the core readable Stream API.\n\n### var valve = new Valve(source, [options])\n\nConstructs and returns a new valve, which listens to the given source.\n\nThis class recognizes all three of the common options (see above), and\nno others.\n\nThe constructed instance obeys the full standard Node stream protocol\nfor readers.\n\n### valve.setIncomingEncoding(name)\n\nSets the incoming encoding of the stream. This is the encoding to use\nwhen interpreting strings that arrive in `data` events. (This is as\nopposed to the encoding set by `setEncoding()` which determines how\nthe collected data is transformed as it gets emitted from an\ninstance.)\n\nThe `name` must be one of the unified allowed encoding names for\n`Stream.setEncoding()`.\n\nThe incoming encoding starts out as `undefined`, which is taken to\nbe synonymous with `\"utf8\"` should a `data` event be received\ncontaining a string payload.\n\n\n* * * * * * * * * *\n\nTo Do\n-----\n\n* Consider adding a common option of `pressure: boolean` to indicate\n  whether `pause()` and `resume()` should recurse upstream.\n\n\nContributing\n------------\n\nQuestions, comments, bug reports, and pull requests are all welcome.\nSubmit them at [the project on GitHub](https://github.com/Obvious/pipette/).\n\nBug reports that include steps-to-reproduce (including code) are the\nbest. Even better, make them in the form of pull requests that update\nthe test suite. Thanks!\n\n\nAuthor\n------\n\n[Dan Bornstein](https://github.com/danfuzz)\n([personal website](http://www.milk.com/)), supported by\n[The Obvious Corporation](http://obvious.com/).\n\nThanks to <https://github.com/rootslab/dropper> for the name of the\n`Dropper` class.\n\n\nLicense\n-------\n\nCopyright 2012 [The Obvious Corporation](http://obvious.com/).\n\nLicensed under the Apache License, Version 2.0.\nSee the top-level file `LICENSE.txt` and\n(http://www.apache.org/licenses/LICENSE-2.0).\n\n\n",
  "_id": "pipette@0.9.1",
  "_from": "pipette@~0.9.1"
}
