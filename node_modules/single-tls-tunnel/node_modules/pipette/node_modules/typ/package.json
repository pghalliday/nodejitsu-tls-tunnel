{
  "name": "typ",
  "version": "0.6.3",
  "keywords": [
    "type",
    "assert",
    "predicate"
  ],
  "description": "Type predicates and assertions for Node",
  "homepage": "https://github.com/Obvious/typ",
  "repository": {
    "type": "git",
    "url": "https://github.com/Obvious/typ.git"
  },
  "licenses": [
    {
      "type": "Apache 2.0",
      "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
    }
  ],
  "author": {
    "name": "Dan Bornstein",
    "email": "danfuzz@milk.com",
    "url": "http://www.milk.com/"
  },
  "maintainers": [
    {
      "name": "Dan Bornstein",
      "email": "danfuzz@obvious.com",
      "url": "http://www.milk.com/"
    }
  ],
  "main": "lib/typ.js",
  "engine": {
    "node": ">=0.6.0"
  },
  "scripts": {
    "test": "node test/test.js"
  },
  "readme": "typ: Type predicates and assertions for Node\n============================================\n\nThis Node module is meant to provide a unified place to ask and\nassert about all the built-in JavaScript and core Node types.\n\n\"Typ\" is German for \"type\". Also, as of this writing, both \"type\" and\n\"types\" were taken in the npm module registry. The name was picked to\nbe both memorable and short, the latter in order to encourage it to be\nused liberally.\n\n\nBuilding and Installing\n-----------------------\n\n```shell\nnpm install typ\n```\n\nOr grab the source. As of this writing, this module has no\ndependencies, so once you have the source, there's nothing more to do\nto \"build\" it.\n\n\nTesting\n-------\n\n```shell\nnpm test\n```\n\nOr\n\n```shell\nnode ./test/test.js\n```\n\n\nAPI Details\n-----------\n\nConstants\n---------\n\nThis module provides some convenient constants. With regards to the\nstring constants, the author finds it handy to use them instead of\nquoted strings, since that makes typos cause more blatant errors.\n\n### BOOLEAN\n\nThis is what's returned by `typeof` when given a boolean value.\n\n### FUNCTION\n\nThis is what's returned by `typeof` when given a function value.\n\n### NUMBER\n\nThis is what's returned by `typeof` when given a numeric value.\n\n### OBJECT\n\nThis is what's returned by `typeof` when given an object value.\n\n### STRING\n\nThis is what's returned by `typeof` when given a string value.\n\n### UNDEFINED\n\nThis is what's returned by `typeof` when given `undefined`.\n\n### ARRAY_PROTOTYPE\n\nThis is the object prototype of array instances.\n\n### FUNCTION_PROTOTYPE\n\nThis is the object prototype of function instances.\n\n### OBJECT_PROTOTYPE\n\nThis is the default object prototype.\n\n\nAssertion Functions\n-------------------\n\nThis module defines both predicates and assertions for a set of types\nthat covers the standard core JavaScript and Node types. For any given\ntype `name`, the predicate is called `isName()` and the assertion is\ncalled `assertName()`. A predicate simply returns a boolean indicating\nwhether or not its value argument is of the appropriate type, and an\nassertion does nothing other than throw a descriptive message if its\nvalue argument is not of the expected type.\n\nPredicates all take a single argument, `value`, the value to test.\nAssertions all take two arguments, `value` as with the predicate, and\nan optional `message` to replace the default message to report in an\nerror in the case of failure. The `message` if specified may contain\nany number of instances of `%s`, which will be substituted with the\ndefault message. `%%` is substituted with a single `%`. No other `%`\nsubstitution is done.\n\nThe following run-down indicates the meaning of the various types, as\nfar as this module is concerned. If being a particular type implies\nalso being some other type(s), then that fact is indicated by an\n\"implies\" line. (Note: Since all values but `undefined` are considered\n`defined`, that fact isn't listed.)\n\n### array: isArray(value), assertArray(value, message)\n\nImplies: object\n\nArrays are what you get when you use the `[...]` array literal syntax\nor the `new Array(...)` constructor.\n\n### boolean: isBoolean(value), assertBoolean(value, message)\n\nThe only two booleans are `true` and `false`. Notably, `Boolean` objects\nare not considered to be booleans here.\n\n### buffer: isBuffer(value), assertBuffer(value, message)\n\nImplies: object\n\nBuffers are Node's standard ordered-list-of-bytes type, created\nwith the `new Buffer(...)` constructor and used all over the place\nin Node.\n\n### date: isDate(value), assertDate(value, message)\n\nImplies: object\n\nDates represent moments in time. They can be created with the\n`new Date(...)` constructor.\n\n### defined: isDefined(value), assertDefined(value, message)\n\nAll values other than `undefined` are `defined`.\n\n### error: isError(value), assertError(value, message)\n\nImplies: object\n\nErrors are the standard exception values in JavaScript. They can\nbe created by using the `new Error(...)` constructor as well\nas sub-class constructors.\n\n### function: isFunction(value), assertFunction(value, message)\n\nImplies: object\n\nFunctions are the things in JavaScript that do work. They can\nbe created by using the `function...` definition and literal\nsyntax, as well as with the `new Function(...)` constructor.\n\n### int: isInt(value), assertInt(value, message)\n\nImplies: number\n\nAn int is an integer value, which is to say a number with no\nfractional part. As far as this module is concerned, there is no\nrange limit on the ints (that is, an int doesn't have to fit in\n32 bits, for example).\n\nNotably, neither positive nor negative `Infinity` qualifies as an int.\n\nIn addition, as a strange edge case, \"negative zero\" is also *not*\nconsidered to be an int. (You can produce a \"negative zero\" value\nin JavaScript with the expression `-1e-1000`. You can differentiate\nit from plain old regular zero by dividing `1` by it and observing\nthat the result is `-Infinity`.)\n\n### map: isMap(value), assertMap(value, message)\n\nImplies: object\n\nA map is any object that behaves like a simple map-type collection.\nIn particular, a map's prototype must be the default object prototype,\nand none of a map's bindings may be dynamic properties. That is,\ngetter and setter functions disqualify an object from being considered\na map.\n\n### null: isNull(value), assertNull(value, message)\n\nThe only value that is null is `null` per se.\n\n### nullish: isNullish(value), assertNullish(value, message)\n\nThe only two values that are considered to be \"nullish\" are `null`\nand `undefined`.\n\n### number: isNumber(value), assertNumber(value, message)\n\nA number is, well, a numeric value. Numbers are what result from\nusing number literals (like `123`) and are returned, for example,\nfrom the methods on the built-in `Math` object.\n\nThe values `Infinity` and `-Infinity` are considered to be numbers.\nThe special value `NaN` is alson considered to be a number, despite\nthe direct expansion of its name to \"Not a Number\".\n\nNotably, `Number` objects are not considered numbers here.\n\n### object: isObject(value), assertObject(value, message)\n\nAn object is an arbitrary mapping of string keys to values. They\ncan be created in any number of ways (and if you need more description\nthan that, you should find a good intro book on JavaScript).\n\nNotably, `null` is *not* considered to be an object (even though\n`typeof null == \"object\"`).\n\n### regexp: isRegExp(value), assertRegExp(value, message)\n\nImplies: object\n\nA regexp is an object that represents a \"regular expression\". They\ncan be created by using the `/.../` literal syntax or the `new RegExp(...)`\nconstructor.\n\n### string: isString(value), assertString(value, message)\n\nA string is an ordered sequence of characters. They can be created\nby using the `'...'` literal syntax and are produced by many standard\nJavaScript functions.\n\nNotably, `String` objects are not considered strings here.\n\n### uint: isUInt(value), assertUInt(value, message)\n\nImplies: int, number\n\nA uint is an unsigned integer, also known as a whole number. That is,\nit's anything that's an int which is also non-negative. `0` is notably\na uint.\n\n### undefined: isUndefined(value), assertUndefined(value, message)\n\nThe only value that is undefined is `undefined`.\n\nNotably, `null` is defined, *not* undefined.\n\n\nMiscellaneous Functions\n-----------------------\n\n### hasDefaultPrototype(obj) -> boolean\n\nReturns `true` if and only if the given object's prototype is the\ndefault one. That is, this is just a convenient way to say:\n\n```\nObject.getPrototypeOf(obj) === OBJECT_PROTOTYPE\n```\n\n### hasOwnProperty(obj, name) -> boolean\n\nThis is a safe version of the per-object `hasOwnProperty()` method.\nYou should use this any time you can't be 100% sure that the object\nyou're checking won't possibly have a binding for `\"hasOwnProperty\"`.\n\n\nTo Do\n-----\n\n* Figure out something to do.\n\n\nContributing\n------------\n\nQuestions, comments, bug reports, and pull requests are all welcome.\nSubmit them at [the project on GitHub](https://github.com/Obvious/typ/).\n\nBug reports that include steps-to-reproduce (including code) are the\nbest. Even better, make them in the form of pull requests that update\nthe test suite. Thanks!\n\n\nAuthor\n------\n\n[Dan Bornstein](https://github.com/danfuzz)\n([personal website](http://www.milk.com/)), supported by\n[The Obvious Corporation](http://obvious.com/).\n\nThanks to [Jeremy Stanley](https://github.com/azulus),\n[Dan Pupius](https://github.com/dpup),\n[Mike Fleming](https://github.com/mikefleming),\nand [Sho Kuwamoto](https://github.com/skuwamoto)\nfor suggestions.\n\n\nLicense\n-------\n\nCopyright 2012 [The Obvious Corporation](http://obvious.com/).\n\nLicensed under the Apache License, Version 2.0. \nSee the top-level file `LICENSE.txt` and\n(http://www.apache.org/licenses/LICENSE-2.0).\n",
  "_id": "typ@0.6.3",
  "_from": "typ@~0.6.1"
}
